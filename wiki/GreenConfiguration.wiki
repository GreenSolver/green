#summary How to configure a Green instantiation

Each new instantiation of Green needs to be told how to "behave".  The easiest way to accomplish this is to pass a `java.util.Properies` instantiation to Green.

{{{
import za.ac.sun.cs.green.Green;
import za.ac.sun.cs.green.util.Configuration;

Green g = new Green();
Properties p = new Properties();
// Load contents of p from file or
// set them manually
new Configuration(g, p).configure();
}}}

The same configuration will also be passed to all `Service` instantiations created during set-up.  Each service may pick up on its own properties; the convention is that these start with "`green.`".

= Green properties =

Green itself reads the following properties.

== Setting the task manager ==

{{{
green.taskmanager = <classname>
}}}

== Setting the store ==

{{{
green.store = <classname>
}}}

== Setting up services ==

Green can be configure with any number of services.  An initial setting determines the initial list of services:

{{{
green.services = <service1>, <service2>, <service3> ...
}}}

If a service `serv` has been configured, and an Instance `inst` has been created, users can invoke the service by calling

{{{
Object r = inst.request("serv");
}}}

The `request` method returns a `java.lang.Object`, the exact nature of which depends on the service.  The nature of the object depends entirely on the services configured.  For example, for a satisfiability service, a typical invocation might be

{{{
Boolean issat = (Boolean) inst.request("sat");
}}}

Services are described as follows:

{{{
green.service.<service> = <service-tree>
}}}

The syntax of the service tree is:

{{{
<service-tree> ::= <child1> <child2> <child3> ...
<child> ::= <service-name> | "(" <service-name> <service-tree> ")"
}}}

Each of the services named in a service tree must also be configured:

{{{
green.service.<service>.<service-name> = <classname>
}}}

An example will illustrate this configuration option more clearly.  A SAT service might typically be described as follows:

{{{
green.services = sat
green.service.sat = (cnf (slice (canonize z3 cvc3 choco)))
green.service.sat.cnf = za.ac.sun.cs.green.service.cnf.CNFService
green.service.sat.slice = za.ac.sun.cs.green.service.slicer.SATSlicerService
green.service.sat.canonize = za.ac.sun.cs.green.service.canonizer.SATCanonizerService
green.service.sat.z3 = za.ac.sun.cs.green.service.z3.SATZ3Service
green.service.sat.cvc3 = za.ac.sun.cs.green.service.cvc3.SATCVC3Service
green.service.sat.choco = za.ac.sun.cs.green.service.choco.SATChocoService
}}}

In this example, a single service named "`sat`" is defined.  It consist of a single child `(cnf ...)`.  This means that any Instance `inst` on which `inst.request("sat")` is invoked, is passed to the `cnf` service, which is implemented by `CNFService.java` in the `za.ac.sun.cs.green.service.cnf` package.  The subproblems produced by that service is in turn passed to its only child `(slice ...)`, the subproblems produced by the slicer are passed to its only child `(canonize ...)`, and the subproblems generated by the canonizer are passed to its three children `z3`, `cvc3`, and `choco`.  These last three are expected to solve the subproblems, and have no children of their own.

If the standard serial task manager is used, the problems are passed each of the children in turn.  For the serial task manager, the order is not determined.  As soon as a child produces a result, the answer is passed back up the service tree, without invoking further children.  In practice this means that, for simple constraints, if Z3 is invoked first, it solves the constraints and CVC3 and Choco are not really needed.  On the other hand, if the standard parallel task manager is in use, the subproblems will be passed to all three decision procedures concurrently; as soon as a result is available, it is be passed up the tree, and the other two decision procedures will be terminated.

= Other standard properties =

TBD